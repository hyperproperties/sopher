// Code generated by sopher (https://github.com/hyperproperties/sopher). DO NOT EDIT.
package main

import (
	"errors"

	sopher "github.com/hyperproperties/sopher/pkg/language"
)

func SlicesEqual[S1, S2 ~[]E, E comparable](s1 S1, s2 S2) bool {
	if len(s1) != len(s2) {
		return false
	}

	for idx := range s1 {
		elem1, elem2 := s1[idx], s2[idx]
		if elem1 != elem2 {
			return false
		}
	}

	return true
}

type Pin []uint

func NewPin(pin ...uint) Pin {
	return pin
}

func (pin Pin) Valid() bool {
	return len(pin) == 4 &&
		pin[0] <= 9 && pin[1] <= 9 && pin[2] <= 9 && pin[3] <= 9
}

var ErrInvalidPin = errors.New("invalid pin")

type PinChecker struct {
	attempt int
}

type Check_0_Model struct {
	pin     Pin
	ret0    bool
	ret1    error
	checker PinChecker
}

var Check_0_Contract sopher.AGHyperContract[Check_0_Model] = sopher.NewAGHyperContract(
	sopher.NewAllAssertion[Check_0_Model](
		// ∀ e.
		sopher.NewUniversalHyperAssertion(1,
			// e.checker.attempt >= 0
			sopher.NewPredicateHyperAssertion(
				func(assignments []Check_0_Model) bool {
					e := assignments[0]
					_ = e
					return e.checker.attempt >= 0
				},
			),
		),
	),
	sopher.NewAllAssertion[Check_0_Model](
		// ∀ e.
		sopher.NewUniversalHyperAssertion(1,
			sopher.NewBinaryHyperAssertion[Check_0_Model](
				// e.ret0
				sopher.NewPredicateHyperAssertion(
					func(assignments []Check_0_Model) bool {
						e := assignments[0]
						_ = e
						return e.ret0
					},
				),
				sopher.LogicalImplication, /* → */
				// e.ret1 == nil
				sopher.NewPredicateHyperAssertion(
					func(assignments []Check_0_Model) bool {
						e := assignments[0]
						_ = e
						return e.ret1 == nil
					},
				),
			),
		),
		// ∀ e.
		sopher.NewUniversalHyperAssertion(1,
			sopher.NewBinaryHyperAssertion[Check_0_Model](
				// !e.pin.Valid()
				sopher.NewPredicateHyperAssertion(
					func(assignments []Check_0_Model) bool {
						e := assignments[0]
						_ = e
						return !e.pin.Valid()
					},
				),
				sopher.LogicalImplication, /* → */
				// !e.ret0
				sopher.NewPredicateHyperAssertion(
					func(assignments []Check_0_Model) bool {
						e := assignments[0]
						_ = e
						return !e.ret0
					},
				),
			),
		),
		// ∀ e.
		sopher.NewUniversalHyperAssertion(1,
			// e.checker.attempt > 3 && !e.ret0
			sopher.NewPredicateHyperAssertion(
				func(assignments []Check_0_Model) bool {
					e := assignments[0]
					_ = e
					return e.checker.attempt > 3 && !e.ret0
				},
			),
		),
		// ∀ e.
		sopher.NewUniversalHyperAssertion(1,
			sopher.NewBinaryHyperAssertion[Check_0_Model](
				// e.ret0
				sopher.NewPredicateHyperAssertion(
					func(assignments []Check_0_Model) bool {
						e := assignments[0]
						_ = e
						return e.ret0
					},
				),
				sopher.LogicalBiimplication, /* ↔ */
				// e.checker.attempt <= 3 && SlicesEqual(e.pin, []uint{3, 1, 4, 1})
				sopher.NewPredicateHyperAssertion(
					func(assignments []Check_0_Model) bool {
						e := assignments[0]
						_ = e
						return e.checker.attempt <= 3 && SlicesEqual(e.pin, []uint{3, 1, 4, 1})
					},
				),
			),
		),
		// ∀ e0 e1.
		sopher.NewUniversalHyperAssertion(2,
			sopher.NewBinaryHyperAssertion[Check_0_Model](
				// e0.ret0 && e1.ret0
				sopher.NewPredicateHyperAssertion(
					func(assignments []Check_0_Model) bool {
						e0, e1 := assignments[0], assignments[1]
						_, _ = e0, e1
						return e0.ret0 && e1.ret0
					},
				),
				sopher.LogicalImplication, /* → */
				// SlicesEqual(e0.pin, e1.pin)
				sopher.NewPredicateHyperAssertion(
					func(assignments []Check_0_Model) bool {
						e0, e1 := assignments[0], assignments[1]
						_, _ = e0, e1
						return SlicesEqual(e0.pin, e1.pin)
					},
				),
			),
		),
	),
)
var Check_0_Call = func(execution Check_0_Model) Check_0_Model {
	wrap := func(checker PinChecker, pin Pin) (bool, error) {
		if checker.attempt < 0 {
			panic("a negative attempt cannot exist")
		}

		checker.attempt++

		if checker.attempt > 3 {
			return false, nil
		}

		if !pin.Valid() {
			return false, ErrInvalidPin
		}

		return SlicesEqual(pin, []uint{3, 1, 4, 1}), nil
	}
	ret0, ret1 := wrap(execution.checker, execution.pin)
	execution.ret0 = ret0
	execution.ret1 = ret1
	return execution
}

// assume: forall e. e.checker.attempt >= 0
// guarantee: forall e. (e.ret0; -> e.ret1 == nil;)
// guarantee: forall e. (;!e.pin.Valid(); -> ;!e.ret0;)
// guarantee: forall e. ;e.checker.attempt > 3 && !e.ret0;
// guarantee: forall e. (e.ret0; <-> e.checker.attempt <= 3 && SlicesEqual(e.pin, []uint{3, 1, 4, 1});)
// guarantee: forall e0 e1. (e0.ret0 && e1.ret0; -> SlicesEqual(e0.pin, e1.pin);)
func (checker PinChecker) Check(pin Pin) (bool, error) {
	callerID := sopher.Caller()
	execution := Check_0_Model{pin: pin, checker: checker}
	assumption, execution, guarantee := Check_0_Contract.Call(callerID, execution, Check_0_Call)
	if assumption.IsFalse() {
		panic("")
	}
	if guarantee.IsFalse() {
		panic("")
	}
	return execution.ret0, execution.ret1
}
